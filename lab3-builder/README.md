# Лабораторная работа №3 — Builder

## Тема

**Builder (строитель, immutable/mutable модели, scope, валидация, идентификаторы, fluent и делегаты)** — реализация паттерна «строитель» на TypeScript с переходом из изменяемых моделей в иммутабельные, поддержкой scope, валидацией и структурой «как в БД» через идентификаторы.

---

## Студент

- **Имя и фамилия:** Савка Никита (Savca Nichita)
- **Группа:** I2302
- **Платформа разработки:** macOS (Apple M3), Node.js / TypeScript
- **Дата выполнения:** 20 октября 2025

---

## Цель и постановка задачи

**Цель:** освоить паттерн Builder на модели «Город–Дома–Жители», показать поэтапную инициализацию, переход из mutable моделей в immutable представление, добавить валидацию и «ID вместо ссылок», а также применить fluent, делегаты конфигурации и scope.

**Требования (выполнены):**

1. Создать группу взаимосвязанных классов (город/дома/жители) и билдеры для их конфигурации.
2. Реализовать иммутабельный выход билдера.
3. Добавить валидацию на уровне конфигурации и при build() (сбор всех ошибок).
4. Продемонстрировать работу в `src/main.ts`.
5. Выполнить ≥3 дополнительных задания ( ниже).

---

## Краткое описание решения

- **Модели:**
  - Immutable: `City`, `Home`, `Citizen` (ID-ориентированные, без прямых ссылок).
  - Mutable: DTO для билдера, с необязательными полями и sourceHint для диагностики.
- **Билдер:**
  - `CityBuilder` — основной объект конфигурации с методами `home(...)` и `citizen(...)`.
  - Fluent API и делегаты конфигурации (например, `builder.citizen(b => b.name(...).age(...))`).
  - Scope для задания общих дефолтов на блок конфигурации.
- **Выход:**
  - `build()` возвращает иммутабельный `City` (`Object.freeze`).
  - Ссылки через идентификаторы (`homeId`) — «как в БД».
- **Валидация:**
  - Валидатор собирает все ошибки (путь к полю, сообщение, sourceHint) и выбрасывает единый `ValidationError`.
- **Тесты:**
  - Vitest, snapshot-тест итоговой структуры.

---

## Структура проекта

```
lab3-builder/
├─ package.json / tsconfig.json / vitest.config.ts
├─ src/
│  ├─ models/
│  │  ├─ immutable.ts      # City/Home/Citizen + утилиты getHome/getCitizen
│  │  └─ mutable.ts        # MutableCityModel / MutableHomeModel / MutableCitizenModel
│  ├─ builder/
│  │  ├─ types.ts          # IHomeBuilder / ICitizenBuilder (интерфейсы для fluent API)
│  │  ├─ CityBuilder.ts    # scope, делегаты конфигурации, build() → immutable
│  │  └─ validation.ts     # validateCityModel + ValidationError (сбор всех ошибок)
│  └─ main.ts              # демонстрация: дома/жители, scope, IDs, build + логи
└─ test/
   └─ builder.spec.ts      # Vitest + snapshot
```

---

## Ключевые компоненты и поведение

- **Mutable → Immutable:** `CityBuilder.build()` формирует массивы `homes[]` и `citizens[]`, присваивает стабильные ID (индексы) и возвращает замороженный `City`.
- **Fluent & Делегаты:** каждый метод билдера возвращает `this`; конфигурация через коллбек повышает наглядность и локальность данных.
- **Scope:** `builder.scope({ citizenAge: 32 }, () => { ... })` — единый дефолт для всех объектов внутри блока.
- **DB-like:** вместо ссылок — `homeId`, доступ к объекту через утилиты `getHome(city, id)`.
- **Валидация:** собирает все ошибки (пустой address, пустое name, отрицательный/NaN age, неверный homeIndex) и показывает понятные пути + sourceHint.
- **Интерфейсы билдера:** `IHomeBuilder`/`ICitizenBuilder` устраняют дублирование, описывают fluent-контракт и high-level методы (`setNameAndAge`, `copyFrom`).

---

## Демонстрация в main.ts

1. Создаём дом `h1` с адресом `"Str. 123"`, сохраняем его индекс `homeIndex`.
2. Входим в `scope({ citizenAge: 32 }, ...)`: дефолтный возраст для всех последующих жителей.
3. Создаём трёх жителей:
   - John — `setNameAndAge("John", 18)` и `homeByIndex(homeIndex)`.
   - Joe — только `name("Joe")` (унаследует age=32, бездомный).
   - Mary — `name("Mary")` и `homeByIndex(homeIndex)`.
4. Вызываем `build()` → получаем `City` (immutable), выводим JSON и проверяем `getHome` для Mary.

---

## Примеры команд

Установить зависимости:

```bash
pnpm install
```

Запустить демонстрацию:

```bash
pnpm run dev    # выполняет src/main.ts
```

Запустить тесты:

```bash
pnpm run test   # Vitest + snapshot
```

Скрипты в package.json:

```json
{
	"scripts": {
		"dev": "tsx src/main.ts",
		"test": "vitest --run"
	}
}
```

---

## Примеры ожидаемых результатов

- **City (JSON):** массивы homes и citizens со стабильными id; у граждан homeId: number | null.
- **Иммутабельность:** `Object.isFrozen(city) === true`.
- **Доступ по ID:** `getHome(city, city.citizens[2].homeId)?.address` → `"Str. 123"`.
- **Ошибки валидации:** единый `ValidationError` со списком всех нарушений (пути к полям + sourceHint, если задан).

---

## Тестирование

Файл: `test/builder.spec.ts`

- Snapshot итоговой структуры City (стабильный порядок/ID).
- Проверка валидации: отсутствие адреса у дома, пустое имя, некорректный возраст, неверный индекс дома — все ошибки собираются и отражаются в сообщении.
- Иммутабельность: `Object.isFrozen(city)`.

---

## Соответствие заданиям

**Обязательная часть — выполнено:**

- Группа связанных классов: City/Home/Citizen (+ mutable-модели).
- Билдеры: CityBuilder, IHomeBuilder, ICitizenBuilder; можно выставить каждое свойство.
- Иммутабельный выход: build() → City (freeze).
- Валидация: базовая логика в валидаторе + сбор всех ошибок.
- Демонстрация: src/main.ts.

**Дополнительные задания — выполнено более 3:**

1. Fluent builder + делегаты конфигурации + scope — да.
2. Unit-тесты + snapshot-тесты — да (Vitest).
3. «База данных» как выходная структура — да (ID вместо ссылок, getHome/getCitizen).
4. Улучшенная валидация — да (аккумуляция ошибок + sourceHint).
5. High-level функции конфигурации — да (`setNameAndAge`, `copyFrom`).

---

## Выводы

1. Реализован полнофункциональный Builder на TypeScript: поэтапная конфигурация, конверсия в immutable модели и «ID-подход».
2. Добавлены современные инженерные практики: fluent API, делегаты, scope, расширенная валидация, snapshot-тесты.
3. Решение строго следует требованиям лабы, оставаясь минималистичным и расширяемым без дублирования кода.

---
